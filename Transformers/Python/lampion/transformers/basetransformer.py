import libcst as cst


class BaseTransformer(cst.CSTTransformer):
    """Base class for metamorphic transformers, provides methods needed for Engine to work.

    This class provides the basic structure of any transformer, inheriting from the CST Transformer.

    There is no "apply()" method, as the intended use of the engine is to
    a) setup the transformer abc, calling abc.reset()
    b) run the transformer using the someCodeTree.visit(abc)
        b.1) transformer sets all required parameters or fails gracefully
    c) postprocessing of transformer state using abc.
    """

    _was_applied: bool = False
    _sql_info = None

    def reset(self):
        """Resets the Transformer to be applied again.

        :raises NotImplementedError
            Iff the Subclasses do not overwrite the parent method.

        after the reset all local state is deleted, the transformer is fully reset.
        It holds:
        >>> a = SomeTransformer()
        >>> b = SomeTransformer()
        >>> someTree.visit(a)
        >>> a.reset()
        >>> assert a == b

        Do not put this in the libcst visit methods!
        The state generated by the visit methods is needed for postprocessing.
        """
        raise NotImplementedError()

    def postprocessing(self):
        """ Manages all behavior after application, in case it worked(). Also calls reset().

        :raises NotImplementedError
            Iff the Subclasses do not overwrite the parent method.

        This method is intended to be run after the libcst visit.
        It needs the state of the
        """
        raise NotImplementedError()

    def worked(self) -> bool:
        """Returns whether the transformer was successfully applied since the last reset

        :returns bool
            True if the Transformer was successfully applied.
            False otherwise.

        This is intended to check for re-trial and to keep track of an intended number of applications.
        Sometimes, a transformer can just be retried or another replacement
        can be run instead to achieve 100 transformations.

        A good example to expect a not-working transformer is renaming variables:
        If there are no variables in a module, the transformer is expected to fail.

        Worked should ALWAYS be reset when the rest() method is called.
        """
        return self._was_applied

    def _can_be_applied(self, node: "BaseNode") -> bool:
        """Checks whether all constraints for the Transformer are met to be applied.

        :parameter node : libcst.BaseNode
            The CST for which the constraints should be checked

        :returns bool
            whether or not the constraints are met. In case of false, visiting a node with this will
            make also give a transformer.worked() == false and not do anything:
            In case of true, the remaining logic is applied as intended.

        :raises NotImplementedError
            Iff the default implementation is not overwritten (subclasses must provide this function).

        This method should also hold all the constraints for a transformer to be applied.

        E.g. the renameParameter transformer should check for existence of parameters, and return false otherwise.

        The constraints should be formulated as error-catching as possible. If a transformer could fail in a certain
        circumstance you are aware of, then add it as a constraint here.
        """
        raise NotImplementedError()

    def _write_sql_entry(self):
        """Writes an entry of this transformer into the manifest.

        Currently TODO
        """
        return 1
