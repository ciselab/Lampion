"""
Contains the "BaseTransformer", a superclass for the other Transformers.
"""
from libcst import CSTNode


class BaseTransformer():
    """Base class for metamorphic transformers, provides methods needed for Engine to work.

    This class provides the basic structure of any transformer, inheriting from the CST Transformer.

    The intended within the engine is to
    a) setup the transformer abc, calling abc.reset()
    b) abc.apply(cst)
        b.1) transformer sets all required parameters or fails gracefully
    c) postprocessing of transformer state using abc.
    """

    _was_applied: bool = False
    _max_tries: int = 25

    def reset(self):
        """Resets the Transformer to be applied again.

        :raises NotImplementedError:
            Iff the Subclasses do not overwrite the parent method.

        after the reset all local state is deleted, the transformer is fully reset.
        It holds:
        >>> a = SomeTransformer()
        >>> b = SomeTransformer()
        >>> someTree.visit(a)
        >>> a.reset()
        >>> assert a == b

        Do not put this in the libcst visit methods!
        The state generated by the visit methods is needed for postprocessing.
        """
        raise NotImplementedError()

    def apply(self, cst_to_alter: CSTNode) -> CSTNode:
        """
        Apply the Transformer to a given CST.
        The returned CST might not be changed, if the transformer did not work (check the worked() method for this).
        The CST-input should not be changed, this behaviour should be covered with tests.

        The internal implementation should rely on LibCSTs visitor pattern:
        https://libcst.readthedocs.io/en/latest/tutorial.html#Build-Visitor-or-Transformer
        The suggested way is to create a Visitor within each transformer that inherits from the visitor class.
        Whatsoever, one could also change the code on a string-basis or in any other way and re-parse it after.

        :param cst_to_alter: The CST that should be altered.
        :return: The altered CST
        """
        raise NotImplementedError()

    def postprocessing(self):
        """ Manages all behavior after application, in case it worked(). Also calls reset().

        :raises NotImplementedError
            Iff the Subclasses do not overwrite the parent method.

        This method is intended to be run after the libcst visit.
        It needs the state of the
        """
        raise NotImplementedError()

    def worked(self) -> bool:
        """Returns whether the transformer was successfully applied since the last reset

        :returns bool:
            True if the Transformer was successfully applied.
            False otherwise.

        This is intended to check for re-trial and to keep track of an intended number of applications.
        Sometimes, a transformer can just be retried or another replacement
        can be run instead to achieve 100 transformations.

        A good example to expect a not-working transformer is renaming variables:
        If there are no variables in a module, the transformer is expected to fail.

        Worked should ALWAYS be reset when the rest() method is called.
        """
        return self._was_applied

    def categories(self) -> [str]:
        """
        Gives the categories specified for this transformer.
        Used only for information and maybe later for filter purposes.
        :return: The categories what this transformer can be summarized with.
        """
        raise NotImplementedError()

    def _can_be_applied(self, node: CSTNode) -> bool:
        """Checks whether all constraints for the Transformer are met to be applied.

        :parameter node : libcst.BaseNode
            The CST for which the constraints should be checked

        :returns bool
            whether or not the constraints are met. In case of false, visiting a node with this will
            make also give a transformer.worked() == false and not do anything:
            In case of true, the remaining logic is applied as intended.

        :raises NotImplementedError
            Iff the default implementation is not overwritten (subclasses must provide this function).

        This method should also hold all the constraints for a transformer to be applied.

        E.g. the renameParameter transformer should check for existence of parameters, and return false otherwise.

        The constraints should be formulated as error-catching as possible. If a transformer could fail in a certain
        circumstance you are aware of, then add it as a constraint here.
        """
        raise NotImplementedError()

    def set_max_tries(self, max_tries: int) -> None:
        """
        Sets the number how often the transformer re-tries itself in case of a bad application.
        Some transformers can fail by design, and retrying is normal and to be expected.
        High numbers of retries however can lead to high computing times.

        :param max: the number of retries per transformer per application
        """
        self._max_tries = max_tries

    def get_max_tries(self) -> int:
        """
        :returns int: the number of retries within one attempt of application
        """
        return self._max_tries
