# Design Notes

This file holds some considerations for the implementation details that occurred throughout the project.

## Alternation Manifest

### Representation on Disk

For the alternation manifest, it should have a list of entries where each entry should have:

- A (fully qualified) methodname
- A (fully qualified) classname
- A list of Transformations

Where each Transformation should have:

- A name / type
- A set of categories it belongs to
- A scope
- A "Before <-> After" of the code, atleast for debugging purposes.

The initial idea for a recording the transformations was a (simple) file in either CSV or JSON.
However, the categories which are of variable length break csv's (in a nice way).
And JSON, while human readable, has an explosion in size and as big-data amounts are to be expected, storing millions of records as JSON is a bad idea.
The same reasoning applies to (plain) xml.

Hence, the data needs to be compressable and support variable length inputs.
Candidates would be binary-serialized xml or Binary-JSON in a compressed format.
Another more exotic candidate would be Java-Serialization of the objects, however then the visualisation is also bound to Java.
As I do not want to poke around in binary data with python, a different idea has been chosen:

SQL & SQLite.

SQLLite is fast, everywhere and supports the required schema in a good way.
SQLLite comes with a build in compression.

There are two further benefits:

- When only using standard SQL and ODBC, the obfuscator can store the manifest in a remote library
- Some queries can be performed on the database, saving time in python

The negative point in using SQL is that it is compared to a file a lot of additional work for both sides, visualisation and writing.

## Obfuscator

### Registration of Transformations

For the Transformations I'd have liked to have a single class per Transformation with a shared interface.
That is all fun and games until it comes to randomly picking a Transformation.

If another component needs to pick amongst all available Transformations, there must be either

- A concept where each Transformation self-registers in an entity
- An Entity knows all available Transformations (God Class)

Both have up and downsides:

The Self-Registering will be more decentralized, sticking closer to object oriented standards (each class is responsible for it's registration).
However, using the self-registered transformations will require the use of reflections, which is horrible to test and hard to understand.

The God-Class breaks with responsibilities and can grow immensely large.
On the other side, it's easier to spot issues and test it, as well as it's easier to get started with in the first place.

**For now, the God Class is chosen**, as in the first prototypes there will be little to no issues with size and only a few Transformations implemented.

### Attributes of Transformations

Transformations come with a variety of possible attributes,
but to have a nicely configurable program it's important to address them probably.

Each Transformation has

- A (unique) name
- A set of categories (such as NLP-Relevant, Structure-Relevant, ...)
- Whether it is (likely to be) a Code-Smell
- Whether it is (likely) to affect generated Bytecode
- A set of Transformations to which it is exclusive
- A set of sanity-checks whether it is applicable

Some Transformations are diametric to each other and hence useless when applied after each other, examples are removing comments versus duplicating comments.
Some Transformations are exclusive to themselves, that is e.g. changing a method name twice does not make sense.

Sanity checks are a super set of exclusiveness-checks and cover things such as that you can't alter variable names for a method that has no variables.
For any `Transformation<T>` the sanity checks can be expressed as a `Set<Predicate<T>>`.

These Attributes should enable a managing component to

1. pick only valid, none code breaking, Transformations for any method
2. pick Transformations based on a specified distribution
