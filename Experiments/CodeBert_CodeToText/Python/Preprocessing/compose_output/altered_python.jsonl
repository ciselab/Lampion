{"url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L180-L206" , "repo": "smdabdoub/phylotoast" , "sha": "0b74ef171e6a84761710548501dfac71285a58a3" , "func_name": "ensure_dir" , "docstring": "Check to make sure the supplied directory path does not exist, if so, create it. The   method catches OSError exceptions and returns a descriptive message instead of   re-raising the error.    :type d: str   :param d: It is the full path to a directory.    :return: Does not return anything, but creates a directory path if it doesn't exist        already." , "docstring_tokens": ["Check", "to", "make", "sure", "the", "supplied", "directory", "path", "does", "not", "exist", "if", "so", "create", "it", ".", "The", "method", "catches", "OSError", "exceptions", "and", "returns", "a", "descriptive", "message", "instead", "of", "re", "-", "raising", "the", "error", "."] , "path": "phylotoast/util.py" , "partition": "train" , "code_tokens": ["def", "ensure_dir", "(", "oG2Lm", ")", ":", "(", "\\", "\\", "\\", "Check", "to", "make", "sure", "the", "supplied", "directory", "path", "does", "not", "exist", ",", "if", "so", ",", "create", "it", ".", "The", "method", "catches", "OSError", "exceptions", "and", "returns", "a", "descriptive", "message", "instead", "of", "re", "-", "raising", "the", "error", ".", ":", "type", "d", ":", "str", ":", "param", "d", ":", "It", "is", "the", "full", "path", "to", "a", "directory", ".", ":", "return", ":", "Does", "not", "return", "anything", ",", "but", "creates", "a", "directory", "path", "if", "it", "doesn't", "exist", "already", ".", "\\", "\\", "\\", "+", "\\", "\\", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "oG2Lm", ")", ":", "try", ":", "os", ".", "makedirs", "(", "oG2Lm", ")", "except", "OSError", "as", "oe", ":", "if", "os", ".", "errno", "=", "=", "errno", ".", "ENOENT", ":", "cefnL", "=", "twdd", "(", "(", "(", "lambda", ":", "\\", "\\", "\\", "One", "or", "more", "directories", "in", "the", "path", "(", "{", "}", ")", "do", "not", "exist", ".", "If", "you", "are", "specifying", "a", "new", "directory", "for", "output", ",", "please", "ensure", "all", "other", "directories", "in", "the", "path", "currently", "exist", ".", "\\", "\\", "\\", ")", "(", ")", ")", ")", "return", "cefnL", ".", "format", "(", "oG2Lm", ")", "else", ":", "cefnL", "=", "twdd", "(", "\\", "\\", "\\", "An", "error", "occurred", "trying", "to", "create", "the", "output", "directory", "(", "{", "}", ")", "with", "message", ":", "{", "}", "\\", "\\", "\\", ")", "return", "cefnL", ".", "format", "(", "oG2Lm", ",", "oe", ".", "strerror", ")"] , "code": "\ndef ensure_dir(oG2Lm):\n  (\"\"\"\n  Check to make sure the supplied directory path does not exist, if so, create it. The\n  method catches OSError exceptions and returns a descriptive message instead of\n  re-raising the error.\n\n  :type d: str\n  :param d: It is the full path to a directory.\n\n  :return: Does not return anything, but creates a directory path if it doesn't exist\n       already.\n  \"\"\" + \"\")\n  if not os.path.exists(oG2Lm):\n    try:\n      os.makedirs(oG2Lm)\n    except OSError as oe:\n      \n      \n      if os.errno == errno.ENOENT:\n        \n        cefnL = twdd(((lambda: \"\"\"One or more directories in the path ({}) do not exist. If\n              you are specifying a new directory for output, please ensure\n              all other directories in the path currently exist.\"\"\")()))\n        return cefnL.format(oG2Lm)\n      else:\n        cefnL = twdd(\"\"\"An error occurred trying to create the output directory\n              ({}) with message: {}\"\"\")\n        return cefnL.format(oG2Lm, oe.strerror)\n  \n" }
{"url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L311-L334" , "repo": "smdabdoub/phylotoast" , "sha": "0b74ef171e6a84761710548501dfac71285a58a3" , "func_name": "parse_unifrac" , "docstring": "Parses the unifrac results file into a dictionary    :type unifracFN: str   :param unifracFN: The path to the unifrac results file    :rtype: dict   :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a        dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and        'varexp' (variation explained)" , "docstring_tokens": ["Parses", "the", "unifrac", "results", "file", "into", "a", "dictionary"] , "path": "phylotoast/util.py" , "partition": "train" , "code_tokens": ["def", "parse_unifrac", "(", "unifracFN", ")", ":", "(", "\\", "\\", "\\", "Parses", "the", "unifrac", "results", "file", "into", "a", "dictionary", ":", "type", "unifracFN", ":", "str", ":", "param", "unifracFN", ":", "The", "path", "to", "the", "unifrac", "results", "file", ":", "rtype", ":", "dict", ":", "return", ":", "A", "dictionary", "with", "keys", ":", "'", "pcd", "'", "(", "principle", "coordinates", "data", ")", "which", "is", "a", "dictionary", "of", "the", "data", "keyed", "by", "sample", "ID", ",", "'", "eigvals", "'", "(", "eigenvalues", ")", ",", "and", "'", "varexp", "'", "(", "variation", "explained", ")", "\\", "\\", "\\", "+", "\\", "\\", ")", "with", "open", "(", "unifracFN", ",", "\\", "rU", "\\", ")", "as", "uF", ":", "opdcl", "=", "uF", ".", "next", "(", ")", ".", "split", "(", "\\", "\\", "\\", "t", "\\", ")", "qKifx", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "uF", "]", "unifrac", "=", "{", "\\", "pcd", "\\", ":", "OrderedDict", "(", ")", ",", "\\", "eigvals", "\\", ":", "[", "]", ",", "\\", "varexp", "\\", ":", "[", "]", "}", "if", "opdcl", "[", "0", "]", "=", "=", "\\", "pc", "vector", "number", "\\", ":", "return", "parse_unifrac_v1_8", "(", "unifrac", ",", "qKifx", ")", "elif", "opdcl", "[", "0", "]", "=", "=", "\\", "Eigvals", "\\", ":", "stream_complex_ibex_gourmet", ":", "int", "=", "768", "return", "parse_unifrac_v1_9", "(", "unifrac", ",", "qKifx", ")", "else", ":", "raise", "ValueError", "(", "\\", "File", "format", "not", "supported", "/", "recognized", ".", "Please", "check", "input", "\\", "\\", "unifrac", "file", ".", "\\", ")"] , "code": "\n\ndef parse_unifrac(unifracFN):\n  (\"\"\"\n  Parses the unifrac results file into a dictionary\n\n  :type unifracFN: str\n  :param unifracFN: The path to the unifrac results file\n\n  :rtype: dict\n  :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a\n       dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and\n       'varexp' (variation explained)\n  \"\"\" + \"\")\n  with open(unifracFN, \"rU\") as uF:\n    opdcl = uF.next().split(\"\\t\")\n    qKifx = [line.strip() for line in uF]\n\n  unifrac = {\"pcd\": OrderedDict(), \"eigvals\": [], \"varexp\": []}\n  if opdcl[0] == \"pc vector number\":\n    return parse_unifrac_v1_8(unifrac, qKifx)\n  elif opdcl[0] == \"Eigvals\":\n    stream_complex_ibex_gourmet: int = 768\n    return parse_unifrac_v1_9(unifrac, qKifx)\n  else:\n    raise ValueError(\"File format not supported/recognized. Please check input \"\n             \"unifrac file.\")\n  \n" }
{"url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L159-L177" , "repo": "smdabdoub/phylotoast" , "sha": "0b74ef171e6a84761710548501dfac71285a58a3" , "func_name": "split_phylogeny" , "docstring": "Return either the full or truncated version of a QIIME-formatted taxonomy string.      :type p: str     :param p: A QIIME-formatted taxonomy string: k__Foo; p__Bar; ...      :type level: str     :param level: The different level of identification are kingdom (k), phylum (p),                   class (c),order (o), family (f), genus (g) and species (s). If level is                   not provided, the default level of identification is species.      :rtype: str     :return: A QIIME-formatted taxonomy string up to the classification given             by param level." , "docstring_tokens": ["Return", "either", "the", "full", "or", "truncated", "version", "of", "a", "QIIME", "-", "formatted", "taxonomy", "string", "."] , "path": "phylotoast/util.py" , "partition": "train" , "code_tokens": ["from_iterative_ibex_nurse", ":", "int", "=", "640def", "split_phylogeny", "(", "p", ",", "xtuie", "=", "\\", "s", "\\", ")", ":", "run_wonderful_starfish_gourmet", ":", "str", "=", "\\", "ypm8pGP6m4R", "\\", "compare_zoomed_beaver_veterinarian", ":", "int", "=", "915", "xtuie", "=", "xtuie", "+", "\\", "__", "\\", "result", "=", "p", ".", "split", "(", "xtuie", ")", "return", "result", "[", "0", "]", "+", "xtuie", "+", "result", "[", "1", "]", ".", "split", "(", "\\", ";", "\\", ")", "[", "0", "]"] , "code": "from_iterative_ibex_nurse: int = 640\n\n\ndef split_phylogeny(p, xtuie=\"s\"):\n    run_wonderful_starfish_gourmet: str = \"ypm8pGP6m4R\"\n    \n    compare_zoomed_beaver_veterinarian: int = 915\n    xtuie = xtuie+\"__\"\n    result = p.split(xtuie)\n    return result[0]+xtuie+result[1].split(\";\")[0]\n    \n" }
{"url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L238-L309" , "repo": "smdabdoub/phylotoast" , "sha": "0b74ef171e6a84761710548501dfac71285a58a3" , "func_name": "gather_categories" , "docstring": "Find the user specified categories in the map and create a dictionary to contain the   relevant data for each type within the categories. Multiple categories will have their   types combined such that each possible combination will have its own entry in the   dictionary.    :type imap: dict   :param imap: The input mapping file data keyed by SampleID   :type header: list   :param header: The header line from the input mapping file. This will be searched for           the user-specified categories   :type categories: list   :param categories: The list of user-specified category column name from mapping file   :rtype: dict   :return: A sorted dictionary keyed on the combinations of all the types found within        the user-specified categories. Each entry will contain an empty DataCategory        namedtuple. If no categories are specified, a single entry with the key        'default' will be returned" , "docstring_tokens": ["Find", "the", "user", "specified", "categories", "in", "the", "map", "and", "create", "a", "dictionary", "to", "contain", "the", "relevant", "data", "for", "each", "type", "within", "the", "categories", ".", "Multiple", "categories", "will", "have", "their", "types", "combined", "such", "that", "each", "possible", "combination", "will", "have", "its", "own", "entry", "in", "the", "dictionary", "."] , "path": "phylotoast/util.py" , "partition": "train" , "code_tokens": ["def", "gather_categories", "(", "imap", ",", "oYpTA", ",", "yujq6", "=", "None", ")", ":", "if", "yujq6", "is", "None", ":", "return", "{", "(", "\\", "default", "\\", "+", "\\", "\\", ")", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "cat_ids", "=", "[", "oYpTA", ".", "index", "(", "cat", ")", "for", "cat", "in", "yujq6", "if", "cat", "in", "oYpTA", "and", "(", "(", "lambda", ":", "lambda", ":", "\\", "=", "\\", ")", "(", ")", "(", ")", ")", "not", "in", "cat", "]", "table", "=", "OrderedDict", "(", ")", "conditions", "=", "defaultdict", "(", "set", ")", "for", "i", ",", "cat", "in", "enumerate", "(", "yujq6", ")", ":", "if", "\\", "=", "\\", "in", "cat", "and", "cat", ".", "split", "(", "\\", "=", "\\", ")", "[", "0", "]", "in", "oYpTA", ":", "cat_name", "=", "oYpTA", "[", "oYpTA", ".", "index", "(", "cat", ".", "split", "(", "\\", "=", "\\", ")", "[", "0", "]", ")", "]", "conditions", "[", "cat_name", "]", ".", "add", "(", "cat", ".", "split", "(", "\\", "=", "\\", ")", "[", "1", "]", ")", "if", "not", "cat_ids", "and", "not", "conditions", ":", "return", "{", "\\", "default", "\\", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "if", "cat_ids", "and", "not", "conditions", ":", "for", "sid", ",", "row", "in", "imap", ".", "items", "(", ")", ":", "cat_name", "=", "\\", "_", "\\", ".", "join", "(", "[", "row", "[", "cid", "]", "for", "cid", "in", "cat_ids", "]", ")", "if", "cat_name", "not", "in", "table", ":", "table", "[", "cat_name", "]", "=", "DataCategory", "(", "set", "(", ")", ",", "{", "}", ")", "table", "[", "cat_name", "]", ".", "sids", ".", "add", "(", "sid", ")", "return", "table", "cond_ids", "=", "set", "(", ")", "for", "k", "in", "conditions", ":", "try", ":", "cond_ids", ".", "add", "(", "oYpTA", ".", "index", "(", "k", ")", ")", "except", "ValueError", ":", "continue", "idx_to_test", "=", "set", "(", "cat_ids", ")", ".", "union", "(", "cond_ids", ")", "for", "sid", ",", "row", "in", "imap", ".", "items", "(", ")", ":", "if", "all", "(", "[", "row", "[", "oYpTA", ".", "index", "(", "c", ")", "]", "in", "conditions", "[", "c", "]", "for", "c", "in", "conditions", "]", ")", ":", "key", "=", "\\", "_", "\\", ".", "join", "(", "[", "row", "[", "idx", "]", "for", "idx", "in", "idx_to_test", "]", ")", "try", ":", "assert", "key", "in", "table", ".", "keys", "(", ")", "except", "AssertionError", ":", "table", "[", "key", "]", "=", "DataCategory", "(", "set", "(", ")", ",", "{", "}", ")", "table", "[", "key", "]", ".", "sids", ".", "add", "(", "sid", ")", "try", ":", "assert", "len", "(", "table", ")", ">", "0", "except", "AssertionError", ":", "return", "{", "\\", "default", "\\", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "else", ":", "return", "table"] , "code": "\ndef gather_categories(imap, oYpTA, yujq6=None):\n  \n  \n  if yujq6 is None:\n    return {(\"default\" + \"\"): DataCategory(set(imap.keys()), {})}\n\n  cat_ids = [oYpTA.index(cat)\n        for cat in yujq6 if cat in oYpTA and ((lambda: lambda: \"=\")()()) not in cat]\n\n  table = OrderedDict()\n  conditions = defaultdict(set)\n  for i, cat in enumerate(yujq6):\n    if \"=\" in cat and cat.split(\"=\")[0] in oYpTA:\n      cat_name = oYpTA[oYpTA.index(cat.split(\"=\")[0])]\n      conditions[cat_name].add(cat.split(\"=\")[1])\n\n  \n  if not cat_ids and not conditions:\n    return {\"default\": DataCategory(set(imap.keys()), {})}\n\n  \n  if cat_ids and not conditions:\n    for sid, row in imap.items():\n      cat_name = \"_\".join([row[cid] for cid in cat_ids])\n      if cat_name not in table:\n        table[cat_name] = DataCategory(set(), {})\n      table[cat_name].sids.add(sid)\n    return table\n\n  \n  cond_ids = set()\n  for k in conditions:\n    try:\n      cond_ids.add(oYpTA.index(k))\n    except ValueError:\n      continue\n  idx_to_test = set(cat_ids).union(cond_ids)\n\n  \n  \n  for sid, row in imap.items():\n    if all([row[oYpTA.index(c)] in conditions[c] for c in conditions]):\n      key = \"_\".join([row[idx] for idx in idx_to_test])\n      try:\n        assert key in table.keys()\n      except AssertionError:\n        table[key] = DataCategory(set(), {})\n      table[key].sids.add(sid)\n  try:\n    assert len(table) > 0\n  except AssertionError:\n    return {\"default\": DataCategory(set(imap.keys()), {})}\n  else:\n    return table\n  \n" }
{"url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L209-L231" , "repo": "smdabdoub/phylotoast" , "sha": "0b74ef171e6a84761710548501dfac71285a58a3" , "func_name": "file_handle" , "docstring": "Takes either a file path or an open file handle, checks validity and returns an open     file handle or raises an appropriate Exception.      :type fnh: str     :param fnh: It is the full path to a file, or open file handle      :type mode: str     :param mode: The way in which this file will be used, for example to read or write or                  both. By default, file will be opened in rU mode.      :return: Returns an opened file for appropriate usage." , "docstring_tokens": ["Takes", "either", "a", "file", "path", "or", "an", "open", "file", "handle", "checks", "validity", "and", "returns", "an", "open", "file", "handle", "or", "raises", "an", "appropriate", "Exception", "."] , "path": "phylotoast/util.py" , "partition": "train" , "code_tokens": ["(", "(", "lambda", ":", "'", "'", "'", "python_helper_header_startur_repo", "smdabdoub", "/", "phylotoast", "ur_repour_url", "https", ":", "/", "/", "github", ".", "com", "/", "smdabdoub", "/", "phylotoast", "/", "blob", "/", "0b74ef171e6a84761710548501dfac71285a58a3", "/", "phylotoast", "/", "util", ".", "py", "#", "L209", "-", "L231", "ur_urlur_path", "phylotoast", "/", "util", ".", "py", "ur_pathur_func_name", "file_handle", "ur_func_nameur_docstring", "b'Takes", "either", "a", "file", "path", "or", "an", "open", "file", "handle", ",", "checks", "validity", "and", "returns", "an", "open", "\\", "file", "handle", "or", "raises", "an", "appropriate", "Exception", ".", "\\", "\\", ":", "type", "fnh", ":", "str", "\\", ":", "param", "fnh", ":", "It", "is", "the", "full", "path", "to", "a", "file", ",", "or", "open", "file", "handle", "\\", "\\", ":", "type", "mode", ":", "str", "\\", ":", "param", "mode", ":", "The", "way", "in", "which", "this", "file", "will", "be", "used", ",", "for", "example", "to", "read", "or", "write", "or", "\\", "both", ".", "By", "default", ",", "file", "will", "be", "opened", "in", "rU", "mode", ".", "\\", "\\", ":", "return", ":", "Returns", "an", "opened", "file", "for", "appropriate", "usage", ".", "'", "ur_docstringur_doctokens", "[", "'", "Takes", "'", ",", "'", "either", "'", ",", "'", "a", "'", ",", "'", "file", "'", ",", "'", "path", "'", ",", "'", "or", "'", ",", "'", "an", "'", ",", "'", "open", "'", ",", "'", "file", "'", ",", "'", "handle", "'", ",", "'", "checks", "'", ",", "'", "validity", "'", ",", "'", "and", "'", ",", "'", "returns", "'", ",", "'", "an", "'", ",", "'", "open", "'", ",", "'", "file", "'", ",", "'", "handle", "'", ",", "'", "or", "'", ",", "'", "raises", "'", ",", "'", "an", "'", ",", "'", "appropriate", "'", ",", "'", "Exception", "'", ",", "'", ".", "'", "]", "ur_doctokensur_sha", "0b74ef171e6a84761710548501dfac71285a58a3", "ur_shaur_partition", "train", "ur_partitionpython_helper_header_end", "'", "'", "'", ")", "(", ")", ")", "def", "file_handle", "(", "yev60", ",", "unXj0", "=", "\\", "rU", "\\", ")", ":", "handle", "=", "None", "if", "isinstance", "(", "yev60", ",", "file", ")", ":", "if", "yev60", ".", "closed", ":", "raise", "ValueError", "(", "\\", "Input", "file", "is", "closed", ".", "\\", ")", "handle", "=", "yev60", "elif", "isinstance", "(", "yev60", ",", "str", ")", ":", "handle", "=", "open", "(", "yev60", ",", "unXj0", ")", "return", "handle"] , "code": "((lambda: '''\npython_helper_header_start\nur_repo smdabdoub/phylotoast ur_repo\nur_url https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L209-L231 ur_url\nur_path phylotoast/util.py ur_path\nur_func_name file_handle ur_func_name\nur_docstring b'Takes either a file path or an open file handle, checks validity and returns an open\\n    file handle or raises an appropriate Exception.\\n\\n    :type fnh: str\\n    :param fnh: It is the full path to a file, or open file handle\\n\\n    :type mode: str\\n    :param mode: The way in which this file will be used, for example to read or write or\\n                 both. By default, file will be opened in rU mode.\\n\\n    :return: Returns an opened file for appropriate usage.' ur_docstring\nur_doctokens ['Takes', 'either', 'a', 'file', 'path', 'or', 'an', 'open', 'file', 'handle', 'checks', 'validity', 'and', 'returns', 'an', 'open', 'file', 'handle', 'or', 'raises', 'an', 'appropriate', 'Exception', '.'] ur_doctokens\nur_sha 0b74ef171e6a84761710548501dfac71285a58a3 ur_sha\nur_partition train ur_partition\npython_helper_header_end\n''')())\ndef file_handle(yev60, unXj0=\"rU\"):\n    \n    \n    handle = None\n    if isinstance(yev60, file):\n        if yev60.closed:\n            raise ValueError(\"Input file is closed.\")\n        handle = yev60\n    elif isinstance(yev60, str):\n        handle = open(yev60, unXj0)\n\n    return handle\n    \n" }
