{"repo": "smdabdoub/phylotoast", "path": "phylotoast/util.py", "func_name": "split_phylogeny", "original_string": "def split_phylogeny(p, level=\"s\"):\n    \"\"\"\n    Return either the full or truncated version of a QIIME-formatted taxonomy string.\n\n    :type p: str\n    :param p: A QIIME-formatted taxonomy string: k__Foo; p__Bar; ...\n\n    :type level: str\n    :param level: The different level of identification are kingdom (k), phylum (p),\n                  class (c),order (o), family (f), genus (g) and species (s). If level is\n                  not provided, the default level of identification is species.\n\n    :rtype: str\n    :return: A QIIME-formatted taxonomy string up to the classification given\n            by param level.\n    \"\"\"\n    level = level+\"__\"\n    result = p.split(level)\n    return result[0]+level+result[1].split(\";\")[0]", "language": "python", "code": "def split_phylogeny(p, level=\"s\"):\n    \"\"\"\n    Return either the full or truncated version of a QIIME-formatted taxonomy string.\n\n    :type p: str\n    :param p: A QIIME-formatted taxonomy string: k__Foo; p__Bar; ...\n\n    :type level: str\n    :param level: The different level of identification are kingdom (k), phylum (p),\n                  class (c),order (o), family (f), genus (g) and species (s). If level is\n                  not provided, the default level of identification is species.\n\n    :rtype: str\n    :return: A QIIME-formatted taxonomy string up to the classification given\n            by param level.\n    \"\"\"\n    level = level+\"__\"\n    result = p.split(level)\n    return result[0]+level+result[1].split(\";\")[0]", "code_tokens": ["def", "split_phylogeny", "(", "p", ",", "level", "=", "\"s\"", ")", ":", "level", "=", "level", "+", "\"__\"", "result", "=", "p", ".", "split", "(", "level", ")", "return", "result", "[", "0", "]", "+", "level", "+", "result", "[", "1", "]", ".", "split", "(", "\";\"", ")", "[", "0", "]"], "docstring": "Return either the full or truncated version of a QIIME-formatted taxonomy string.\n\n    :type p: str\n    :param p: A QIIME-formatted taxonomy string: k__Foo; p__Bar; ...\n\n    :type level: str\n    :param level: The different level of identification are kingdom (k), phylum (p),\n                  class (c),order (o), family (f), genus (g) and species (s). If level is\n                  not provided, the default level of identification is species.\n\n    :rtype: str\n    :return: A QIIME-formatted taxonomy string up to the classification given\n            by param level.", "docstring_tokens": ["Return", "either", "the", "full", "or", "truncated", "version", "of", "a", "QIIME", "-", "formatted", "taxonomy", "string", "."], "sha": "0b74ef171e6a84761710548501dfac71285a58a3", "url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L159-L177", "partition": "train"}
{"repo": "smdabdoub/phylotoast", "path": "phylotoast/util.py", "func_name": "ensure_dir", "original_string": "def ensure_dir(d):\n    \"\"\"\n    Check to make sure the supplied directory path does not exist, if so, create it. The\n    method catches OSError exceptions and returns a descriptive message instead of\n    re-raising the error.\n\n    :type d: str\n    :param d: It is the full path to a directory.\n\n    :return: Does not return anything, but creates a directory path if it doesn't exist\n             already.\n    \"\"\"\n    if not os.path.exists(d):\n        try:\n            os.makedirs(d)\n        except OSError as oe:\n            # should not happen with os.makedirs\n            # ENOENT: No such file or directory\n            if os.errno == errno.ENOENT:\n                msg = twdd(\"\"\"One or more directories in the path ({}) do not exist. If\n                           you are specifying a new directory for output, please ensure\n                           all other directories in the path currently exist.\"\"\")\n                return msg.format(d)\n            else:\n                msg = twdd(\"\"\"An error occurred trying to create the output directory\n                           ({}) with message: {}\"\"\")\n                return msg.format(d, oe.strerror)", "language": "python", "code": "def ensure_dir(d):\n    \"\"\"\n    Check to make sure the supplied directory path does not exist, if so, create it. The\n    method catches OSError exceptions and returns a descriptive message instead of\n    re-raising the error.\n\n    :type d: str\n    :param d: It is the full path to a directory.\n\n    :return: Does not return anything, but creates a directory path if it doesn't exist\n             already.\n    \"\"\"\n    if not os.path.exists(d):\n        try:\n            os.makedirs(d)\n        except OSError as oe:\n            # should not happen with os.makedirs\n            # ENOENT: No such file or directory\n            if os.errno == errno.ENOENT:\n                msg = twdd(\"\"\"One or more directories in the path ({}) do not exist. If\n                           you are specifying a new directory for output, please ensure\n                           all other directories in the path currently exist.\"\"\")\n                return msg.format(d)\n            else:\n                msg = twdd(\"\"\"An error occurred trying to create the output directory\n                           ({}) with message: {}\"\"\")\n                return msg.format(d, oe.strerror)", "code_tokens": ["def", "ensure_dir", "(", "d", ")", ":", "if", "not", "os", ".", "path", ".", "exists", "(", "d", ")", ":", "try", ":", "os", ".", "makedirs", "(", "d", ")", "except", "OSError", "as", "oe", ":", "# should not happen with os.makedirs", "# ENOENT: No such file or directory", "if", "os", ".", "errno", "==", "errno", ".", "ENOENT", ":", "msg", "=", "twdd", "(", "\"\"\"One or more directories in the path ({}) do not exist. If\n                           you are specifying a new directory for output, please ensure\n                           all other directories in the path currently exist.\"\"\"", ")", "return", "msg", ".", "format", "(", "d", ")", "else", ":", "msg", "=", "twdd", "(", "\"\"\"An error occurred trying to create the output directory\n                           ({}) with message: {}\"\"\"", ")", "return", "msg", ".", "format", "(", "d", ",", "oe", ".", "strerror", ")"], "docstring": "Check to make sure the supplied directory path does not exist, if so, create it. The\n    method catches OSError exceptions and returns a descriptive message instead of\n    re-raising the error.\n\n    :type d: str\n    :param d: It is the full path to a directory.\n\n    :return: Does not return anything, but creates a directory path if it doesn't exist\n             already.", "docstring_tokens": ["Check", "to", "make", "sure", "the", "supplied", "directory", "path", "does", "not", "exist", "if", "so", "create", "it", ".", "The", "method", "catches", "OSError", "exceptions", "and", "returns", "a", "descriptive", "message", "instead", "of", "re", "-", "raising", "the", "error", "."], "sha": "0b74ef171e6a84761710548501dfac71285a58a3", "url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L180-L206", "partition": "train"}
{"repo": "smdabdoub/phylotoast", "path": "phylotoast/util.py", "func_name": "file_handle", "original_string": "def file_handle(fnh, mode=\"rU\"):\n    \"\"\"\n    Takes either a file path or an open file handle, checks validity and returns an open\n    file handle or raises an appropriate Exception.\n\n    :type fnh: str\n    :param fnh: It is the full path to a file, or open file handle\n\n    :type mode: str\n    :param mode: The way in which this file will be used, for example to read or write or\n                 both. By default, file will be opened in rU mode.\n\n    :return: Returns an opened file for appropriate usage.\n    \"\"\"\n    handle = None\n    if isinstance(fnh, file):\n        if fnh.closed:\n            raise ValueError(\"Input file is closed.\")\n        handle = fnh\n    elif isinstance(fnh, str):\n        handle = open(fnh, mode)\n\n    return handle", "language": "python", "code": "def file_handle(fnh, mode=\"rU\"):\n    \"\"\"\n    Takes either a file path or an open file handle, checks validity and returns an open\n    file handle or raises an appropriate Exception.\n\n    :type fnh: str\n    :param fnh: It is the full path to a file, or open file handle\n\n    :type mode: str\n    :param mode: The way in which this file will be used, for example to read or write or\n                 both. By default, file will be opened in rU mode.\n\n    :return: Returns an opened file for appropriate usage.\n    \"\"\"\n    handle = None\n    if isinstance(fnh, file):\n        if fnh.closed:\n            raise ValueError(\"Input file is closed.\")\n        handle = fnh\n    elif isinstance(fnh, str):\n        handle = open(fnh, mode)\n\n    return handle", "code_tokens": ["def", "file_handle", "(", "fnh", ",", "mode", "=", "\"rU\"", ")", ":", "handle", "=", "None", "if", "isinstance", "(", "fnh", ",", "file", ")", ":", "if", "fnh", ".", "closed", ":", "raise", "ValueError", "(", "\"Input file is closed.\"", ")", "handle", "=", "fnh", "elif", "isinstance", "(", "fnh", ",", "str", ")", ":", "handle", "=", "open", "(", "fnh", ",", "mode", ")", "return", "handle"], "docstring": "Takes either a file path or an open file handle, checks validity and returns an open\n    file handle or raises an appropriate Exception.\n\n    :type fnh: str\n    :param fnh: It is the full path to a file, or open file handle\n\n    :type mode: str\n    :param mode: The way in which this file will be used, for example to read or write or\n                 both. By default, file will be opened in rU mode.\n\n    :return: Returns an opened file for appropriate usage.", "docstring_tokens": ["Takes", "either", "a", "file", "path", "or", "an", "open", "file", "handle", "checks", "validity", "and", "returns", "an", "open", "file", "handle", "or", "raises", "an", "appropriate", "Exception", "."], "sha": "0b74ef171e6a84761710548501dfac71285a58a3", "url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L209-L231", "partition": "train"}
{"repo": "smdabdoub/phylotoast", "path": "phylotoast/util.py", "func_name": "gather_categories", "original_string": "def gather_categories(imap, header, categories=None):\n    \"\"\"\n    Find the user specified categories in the map and create a dictionary to contain the\n    relevant data for each type within the categories. Multiple categories will have their\n    types combined such that each possible combination will have its own entry in the\n    dictionary.\n\n    :type imap: dict\n    :param imap: The input mapping file data keyed by SampleID\n    :type header: list\n    :param header: The header line from the input mapping file. This will be searched for\n                   the user-specified categories\n    :type categories: list\n    :param categories: The list of user-specified category column name from mapping file\n    :rtype: dict\n    :return: A sorted dictionary keyed on the combinations of all the types found within\n             the user-specified categories. Each entry will contain an empty DataCategory\n             namedtuple. If no categories are specified, a single entry with the key\n             'default' will be returned\n    \"\"\"\n    # If no categories provided, return all SampleIDs\n    if categories is None:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n\n    cat_ids = [header.index(cat)\n               for cat in categories if cat in header and \"=\" not in cat]\n\n    table = OrderedDict()\n    conditions = defaultdict(set)\n    for i, cat in enumerate(categories):\n        if \"=\" in cat and cat.split(\"=\")[0] in header:\n            cat_name = header[header.index(cat.split(\"=\")[0])]\n            conditions[cat_name].add(cat.split(\"=\")[1])\n\n    # If invalid categories or conditions identified, return all SampleIDs\n    if not cat_ids and not conditions:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n\n    #If only category column given, return column-wise SampleIDs\n    if cat_ids and not conditions:\n        for sid, row in imap.items():\n            cat_name = \"_\".join([row[cid] for cid in cat_ids])\n            if cat_name not in table:\n                table[cat_name] = DataCategory(set(), {})\n            table[cat_name].sids.add(sid)\n        return table\n\n    # Collect all condition names\n    cond_ids = set()\n    for k in conditions:\n        try:\n            cond_ids.add(header.index(k))\n        except ValueError:\n            continue\n    idx_to_test = set(cat_ids).union(cond_ids)\n\n    # If column name and condition given, return overlapping SampleIDs of column and\n    # condition combinations\n    for sid, row in imap.items():\n        if all([row[header.index(c)] in conditions[c] for c in conditions]):\n            key = \"_\".join([row[idx] for idx in idx_to_test])\n            try:\n                assert key in table.keys()\n            except AssertionError:\n                table[key] = DataCategory(set(), {})\n            table[key].sids.add(sid)\n    try:\n        assert len(table) > 0\n    except AssertionError:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n    else:\n        return table", "language": "python", "code": "def gather_categories(imap, header, categories=None):\n    \"\"\"\n    Find the user specified categories in the map and create a dictionary to contain the\n    relevant data for each type within the categories. Multiple categories will have their\n    types combined such that each possible combination will have its own entry in the\n    dictionary.\n\n    :type imap: dict\n    :param imap: The input mapping file data keyed by SampleID\n    :type header: list\n    :param header: The header line from the input mapping file. This will be searched for\n                   the user-specified categories\n    :type categories: list\n    :param categories: The list of user-specified category column name from mapping file\n    :rtype: dict\n    :return: A sorted dictionary keyed on the combinations of all the types found within\n             the user-specified categories. Each entry will contain an empty DataCategory\n             namedtuple. If no categories are specified, a single entry with the key\n             'default' will be returned\n    \"\"\"\n    # If no categories provided, return all SampleIDs\n    if categories is None:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n\n    cat_ids = [header.index(cat)\n               for cat in categories if cat in header and \"=\" not in cat]\n\n    table = OrderedDict()\n    conditions = defaultdict(set)\n    for i, cat in enumerate(categories):\n        if \"=\" in cat and cat.split(\"=\")[0] in header:\n            cat_name = header[header.index(cat.split(\"=\")[0])]\n            conditions[cat_name].add(cat.split(\"=\")[1])\n\n    # If invalid categories or conditions identified, return all SampleIDs\n    if not cat_ids and not conditions:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n\n    #If only category column given, return column-wise SampleIDs\n    if cat_ids and not conditions:\n        for sid, row in imap.items():\n            cat_name = \"_\".join([row[cid] for cid in cat_ids])\n            if cat_name not in table:\n                table[cat_name] = DataCategory(set(), {})\n            table[cat_name].sids.add(sid)\n        return table\n\n    # Collect all condition names\n    cond_ids = set()\n    for k in conditions:\n        try:\n            cond_ids.add(header.index(k))\n        except ValueError:\n            continue\n    idx_to_test = set(cat_ids).union(cond_ids)\n\n    # If column name and condition given, return overlapping SampleIDs of column and\n    # condition combinations\n    for sid, row in imap.items():\n        if all([row[header.index(c)] in conditions[c] for c in conditions]):\n            key = \"_\".join([row[idx] for idx in idx_to_test])\n            try:\n                assert key in table.keys()\n            except AssertionError:\n                table[key] = DataCategory(set(), {})\n            table[key].sids.add(sid)\n    try:\n        assert len(table) > 0\n    except AssertionError:\n        return {\"default\": DataCategory(set(imap.keys()), {})}\n    else:\n        return table", "code_tokens": ["def", "gather_categories", "(", "imap", ",", "header", ",", "categories", "=", "None", ")", ":", "# If no categories provided, return all SampleIDs", "if", "categories", "is", "None", ":", "return", "{", "\"default\"", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "cat_ids", "=", "[", "header", ".", "index", "(", "cat", ")", "for", "cat", "in", "categories", "if", "cat", "in", "header", "and", "\"=\"", "not", "in", "cat", "]", "table", "=", "OrderedDict", "(", ")", "conditions", "=", "defaultdict", "(", "set", ")", "for", "i", ",", "cat", "in", "enumerate", "(", "categories", ")", ":", "if", "\"=\"", "in", "cat", "and", "cat", ".", "split", "(", "\"=\"", ")", "[", "0", "]", "in", "header", ":", "cat_name", "=", "header", "[", "header", ".", "index", "(", "cat", ".", "split", "(", "\"=\"", ")", "[", "0", "]", ")", "]", "conditions", "[", "cat_name", "]", ".", "add", "(", "cat", ".", "split", "(", "\"=\"", ")", "[", "1", "]", ")", "# If invalid categories or conditions identified, return all SampleIDs", "if", "not", "cat_ids", "and", "not", "conditions", ":", "return", "{", "\"default\"", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "#If only category column given, return column-wise SampleIDs", "if", "cat_ids", "and", "not", "conditions", ":", "for", "sid", ",", "row", "in", "imap", ".", "items", "(", ")", ":", "cat_name", "=", "\"_\"", ".", "join", "(", "[", "row", "[", "cid", "]", "for", "cid", "in", "cat_ids", "]", ")", "if", "cat_name", "not", "in", "table", ":", "table", "[", "cat_name", "]", "=", "DataCategory", "(", "set", "(", ")", ",", "{", "}", ")", "table", "[", "cat_name", "]", ".", "sids", ".", "add", "(", "sid", ")", "return", "table", "# Collect all condition names", "cond_ids", "=", "set", "(", ")", "for", "k", "in", "conditions", ":", "try", ":", "cond_ids", ".", "add", "(", "header", ".", "index", "(", "k", ")", ")", "except", "ValueError", ":", "continue", "idx_to_test", "=", "set", "(", "cat_ids", ")", ".", "union", "(", "cond_ids", ")", "# If column name and condition given, return overlapping SampleIDs of column and", "# condition combinations", "for", "sid", ",", "row", "in", "imap", ".", "items", "(", ")", ":", "if", "all", "(", "[", "row", "[", "header", ".", "index", "(", "c", ")", "]", "in", "conditions", "[", "c", "]", "for", "c", "in", "conditions", "]", ")", ":", "key", "=", "\"_\"", ".", "join", "(", "[", "row", "[", "idx", "]", "for", "idx", "in", "idx_to_test", "]", ")", "try", ":", "assert", "key", "in", "table", ".", "keys", "(", ")", "except", "AssertionError", ":", "table", "[", "key", "]", "=", "DataCategory", "(", "set", "(", ")", ",", "{", "}", ")", "table", "[", "key", "]", ".", "sids", ".", "add", "(", "sid", ")", "try", ":", "assert", "len", "(", "table", ")", ">", "0", "except", "AssertionError", ":", "return", "{", "\"default\"", ":", "DataCategory", "(", "set", "(", "imap", ".", "keys", "(", ")", ")", ",", "{", "}", ")", "}", "else", ":", "return", "table"], "docstring": "Find the user specified categories in the map and create a dictionary to contain the\n    relevant data for each type within the categories. Multiple categories will have their\n    types combined such that each possible combination will have its own entry in the\n    dictionary.\n\n    :type imap: dict\n    :param imap: The input mapping file data keyed by SampleID\n    :type header: list\n    :param header: The header line from the input mapping file. This will be searched for\n                   the user-specified categories\n    :type categories: list\n    :param categories: The list of user-specified category column name from mapping file\n    :rtype: dict\n    :return: A sorted dictionary keyed on the combinations of all the types found within\n             the user-specified categories. Each entry will contain an empty DataCategory\n             namedtuple. If no categories are specified, a single entry with the key\n             'default' will be returned", "docstring_tokens": ["Find", "the", "user", "specified", "categories", "in", "the", "map", "and", "create", "a", "dictionary", "to", "contain", "the", "relevant", "data", "for", "each", "type", "within", "the", "categories", ".", "Multiple", "categories", "will", "have", "their", "types", "combined", "such", "that", "each", "possible", "combination", "will", "have", "its", "own", "entry", "in", "the", "dictionary", "."], "sha": "0b74ef171e6a84761710548501dfac71285a58a3", "url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L238-L309", "partition": "train"}
{"repo": "smdabdoub/phylotoast", "path": "phylotoast/util.py", "func_name": "parse_unifrac", "original_string": "def parse_unifrac(unifracFN):\n    \"\"\"\n    Parses the unifrac results file into a dictionary\n\n    :type unifracFN: str\n    :param unifracFN: The path to the unifrac results file\n\n    :rtype: dict\n    :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a\n             dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and\n             'varexp' (variation explained)\n    \"\"\"\n    with open(unifracFN, \"rU\") as uF:\n        first = uF.next().split(\"\\t\")\n        lines = [line.strip() for line in uF]\n\n    unifrac = {\"pcd\": OrderedDict(), \"eigvals\": [], \"varexp\": []}\n    if first[0] == \"pc vector number\":\n        return parse_unifrac_v1_8(unifrac, lines)\n    elif first[0] == \"Eigvals\":\n        return parse_unifrac_v1_9(unifrac, lines)\n    else:\n        raise ValueError(\"File format not supported/recognized. Please check input \"\n                         \"unifrac file.\")", "language": "python", "code": "def parse_unifrac(unifracFN):\n    \"\"\"\n    Parses the unifrac results file into a dictionary\n\n    :type unifracFN: str\n    :param unifracFN: The path to the unifrac results file\n\n    :rtype: dict\n    :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a\n             dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and\n             'varexp' (variation explained)\n    \"\"\"\n    with open(unifracFN, \"rU\") as uF:\n        first = uF.next().split(\"\\t\")\n        lines = [line.strip() for line in uF]\n\n    unifrac = {\"pcd\": OrderedDict(), \"eigvals\": [], \"varexp\": []}\n    if first[0] == \"pc vector number\":\n        return parse_unifrac_v1_8(unifrac, lines)\n    elif first[0] == \"Eigvals\":\n        return parse_unifrac_v1_9(unifrac, lines)\n    else:\n        raise ValueError(\"File format not supported/recognized. Please check input \"\n                         \"unifrac file.\")", "code_tokens": ["def", "parse_unifrac", "(", "unifracFN", ")", ":", "with", "open", "(", "unifracFN", ",", "\"rU\"", ")", "as", "uF", ":", "first", "=", "uF", ".", "next", "(", ")", ".", "split", "(", "\"\\t\"", ")", "lines", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "uF", "]", "unifrac", "=", "{", "\"pcd\"", ":", "OrderedDict", "(", ")", ",", "\"eigvals\"", ":", "[", "]", ",", "\"varexp\"", ":", "[", "]", "}", "if", "first", "[", "0", "]", "==", "\"pc vector number\"", ":", "return", "parse_unifrac_v1_8", "(", "unifrac", ",", "lines", ")", "elif", "first", "[", "0", "]", "==", "\"Eigvals\"", ":", "return", "parse_unifrac_v1_9", "(", "unifrac", ",", "lines", ")", "else", ":", "raise", "ValueError", "(", "\"File format not supported/recognized. Please check input \"", "\"unifrac file.\"", ")"], "docstring": "Parses the unifrac results file into a dictionary\n\n    :type unifracFN: str\n    :param unifracFN: The path to the unifrac results file\n\n    :rtype: dict\n    :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a\n             dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and\n             'varexp' (variation explained)", "docstring_tokens": ["Parses", "the", "unifrac", "results", "file", "into", "a", "dictionary"], "sha": "0b74ef171e6a84761710548501dfac71285a58a3", "url": "https://github.com/smdabdoub/phylotoast/blob/0b74ef171e6a84761710548501dfac71285a58a3/phylotoast/util.py#L311-L334", "partition": "train"}
