{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.copyTo", "original_string": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "public", "long", "copyTo", "(", "CharSink", "sink", ")", "throws", "IOException", "{", "checkNotNull", "(", "sink", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "Writer", "writer", "=", "closer", ".", "register", "(", "sink", ".", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "copy", "(", "reader", ",", "writer", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Copies the contents of this source to the given sink.\n\n@return the number of characters copied\n@throws IOException if an I/O error occurs while reading from this source or writing to {@code\nsink}", "docstring_tokens": ["Copies", "the", "contents", "of", "this", "source", "to", "the", "given", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L208-L222", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.read", "original_string": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "String", "read", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "toString", "(", "reader", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads the contents of this source as a string.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "the", "contents", "of", "this", "source", "as", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L229-L239", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.readLines", "original_string": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "ImmutableList", "<", "String", ">", "readLines", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "BufferedReader", "reader", "=", "closer", ".", "register", "(", "openBufferedStream", "(", ")", ")", ";", "List", "<", "String", ">", "result", "=", "Lists", ".", "newArrayList", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "add", "(", "line", ")", ";", "}", "return", "ImmutableList", ".", "copyOf", "(", "result", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads all the lines of this source as a list of strings. The returned list will be empty if\nthis source is empty.\n\n<p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\ntext that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n\\n}. If the source's content does not end in a line termination sequence, it is treated as if\nit does.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "all", "the", "lines", "of", "this", "source", "as", "a", "list", "of", "strings", ".", "The", "returned", "list", "will", "be", "empty", "if", "this", "source", "is", "empty", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L275-L290", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.read", "original_string": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "language": "java", "code": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "code_tokens": ["@", "Override", "public", "int", "read", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Obey InputStream contract.", "checkPositionIndexes", "(", "off", ",", "off", "+", "len", ",", "b", ".", "length", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "// The rest of this method implements the process described by the CharsetEncoder javadoc.", "int", "totalBytesRead", "=", "0", ";", "boolean", "doneEncoding", "=", "endOfInput", ";", "DRAINING", ":", "while", "(", "true", ")", "{", "// We stay in draining mode until there are no bytes left in the output buffer. Then we go", "// back to encoding/flushing.", "if", "(", "draining", ")", "{", "totalBytesRead", "+=", "drain", "(", "b", ",", "off", "+", "totalBytesRead", ",", "len", "-", "totalBytesRead", ")", ";", "if", "(", "totalBytesRead", "==", "len", "||", "doneFlushing", ")", "{", "return", "(", "totalBytesRead", ">", "0", ")", "?", "totalBytesRead", ":", "-", "1", ";", "}", "draining", "=", "false", ";", "byteBuffer", ".", "clear", "(", ")", ";", "}", "while", "(", "true", ")", "{", "// We call encode until there is no more input. The last call to encode will have endOfInput", "// == true. Then there is a final call to flush.", "CoderResult", "result", ";", "if", "(", "doneFlushing", ")", "{", "result", "=", "CoderResult", ".", "UNDERFLOW", ";", "}", "else", "if", "(", "doneEncoding", ")", "{", "result", "=", "encoder", ".", "flush", "(", "byteBuffer", ")", ";", "}", "else", "{", "result", "=", "encoder", ".", "encode", "(", "charBuffer", ",", "byteBuffer", ",", "endOfInput", ")", ";", "}", "if", "(", "result", ".", "isOverflow", "(", ")", ")", "{", "// Not enough room in output buffer--drain it, creating a bigger buffer if necessary.", "startDraining", "(", "true", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "result", ".", "isUnderflow", "(", ")", ")", "{", "// If encoder underflows, it means either:", "// a) the final flush() succeeded; next drain (then done)", "// b) we encoded all of the input; next flush", "// c) we ran of out input to encode; next read more input", "if", "(", "doneEncoding", ")", "{", "// (a)", "doneFlushing", "=", "true", ";", "startDraining", "(", "false", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "endOfInput", ")", "{", "// (b)", "doneEncoding", "=", "true", ";", "}", "else", "{", "// (c)", "readMoreChars", "(", ")", ";", "}", "}", "else", "if", "(", "result", ".", "isError", "(", ")", ")", "{", "// Only reach here if a CharsetEncoder with non-REPLACE settings is used.", "result", ".", "throwException", "(", ")", ";", "return", "0", ";", "// Not called.", "}", "}", "}", "}"], "docstring": "buffer when possible.", "docstring_tokens": ["buffer", "when", "possible", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L124-L186", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.grow", "original_string": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "language": "java", "code": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "code_tokens": ["private", "static", "CharBuffer", "grow", "(", "CharBuffer", "buf", ")", "{", "char", "[", "]", "copy", "=", "Arrays", ".", "copyOf", "(", "buf", ".", "array", "(", ")", ",", "buf", ".", "capacity", "(", ")", "*", "2", ")", ";", "CharBuffer", "bigger", "=", "CharBuffer", ".", "wrap", "(", "copy", ")", ";", "bigger", ".", "position", "(", "buf", ".", "position", "(", ")", ")", ";", "bigger", ".", "limit", "(", "buf", ".", "limit", "(", ")", ")", ";", "return", "bigger", ";", "}"], "docstring": "Returns a new CharBuffer identical to buf, except twice the capacity.", "docstring_tokens": ["Returns", "a", "new", "CharBuffer", "identical", "to", "buf", "except", "twice", "the", "capacity", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L189-L195", "partition": "valid"}
